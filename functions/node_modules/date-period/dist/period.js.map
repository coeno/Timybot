{"version":3,"sources":["../src/period.js"],"names":["filterDate","date","toDate","Object","prototype","toString","call","Error","Date","createPeriod","start","duration","end","recurrence","iso","split","parseInt","substr","addTo","period","i","toArray","length","toISOString"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;;;;;;AAEA,IAAMA,aAAa,SAAbA,UAAa,OAAQ;AACzB,MAAI,OAAOC,KAAKC,MAAZ,KAAuB,UAA3B,EAAuC;AACrCD,WAAOA,KAAKC,MAAL,EAAP;AACD;;AAED,MAAIC,OAAOC,SAAP,CAAiBC,QAAjB,CAA0BC,IAA1B,CAA+BL,IAA/B,MAAyC,eAA7C,EAA8D;AAC5D,UAAM,IAAIM,KAAJ,CAAU,cAAV,CAAN;AACD;;AAED,SAAO,IAAIC,IAAJ,CAAS,CAACP,IAAV,CAAP;AACD,CAVD;;AAYA,SAASQ,YAAT,OAAgE;AAAA;;AAAA,MAAxCC,KAAwC,QAAxCA,KAAwC;AAAA,MAAjCC,QAAiC,QAAjCA,QAAiC;AAAA,MAAvBC,GAAuB,QAAvBA,GAAuB;AAAA,MAAlBC,UAAkB,QAAlBA,UAAkB;AAAA,MAANC,GAAM,QAANA,GAAM;;AAC9D,MAAIA,GAAJ,EAAS;AACP,QAAI,OAAOA,GAAP,KAAe,QAAf,IAA2BA,IAAI,CAAJ,MAAW,GAA1C,EAA+C;AAC7C,YAAM,IAAIP,KAAJ,CAAU,qCAAV,CAAN;AACD;;AAHM,qBAKyBO,IAAIC,KAAJ,CAAU,IAAV,CALzB;;AAAA;;AAKNF,cALM;AAKMH,SALN;AAKaC,YALb;;;AAOPD,YAAQ,IAAIF,IAAJ,CAASE,KAAT,CAAR;AACAG,iBAAaG,SAASH,WAAWI,MAAX,CAAkB,CAAlB,CAAT,EAA+B,EAA/B,CAAb;AACD;;AAEDP,UAAQV,WAAWU,KAAX,CAAR;;AAEA,MAAI,QAAOC,QAAP,uDAAOA,QAAP,OAAoB,QAApB,IAAgC,OAAOA,SAASN,QAAhB,KAA6B,UAAjE,EAA6E;AAC3EM,eAAWA,SAASN,QAAT,EAAX;AACD;;AAEDM,aAAW,4BAAeA,QAAf,CAAX;;AAEA,MAAIC,GAAJ,EAAS;AACPA,UAAMZ,WAAWY,GAAX,CAAN;AACD,GAFD,MAEO,IAAIC,UAAJ,EAAgB;AACrB,QAAI,OAAOA,UAAP,KAAsB,QAA1B,EAAoC;AAClC,YAAM,IAAIN,KAAJ,CAAU,gDAAV,CAAN;AACD;AACF,GAJM,MAIA;AACL,UAAM,IAAIA,KAAJ,CAAU,uDAAV,CAAN;AACD;;AAED,MAAIK,OAAOF,SAASE,GAApB,EAAyB;AACvB,UAAM,IAAIL,KAAJ,CAAU,8CAAV,CAAN;AACD;;AAED,MAAI,CAACG,KAAD,KAAW,CAACC,SAASO,KAAT,CAAeR,KAAf,CAAhB,EAAuC;AACrC,UAAM,IAAIH,KAAJ,gCAAN;AACD;;AAED,MAAIY;AAAA;AAAA;AAAA;AAAA;AAAA;AAEIlB,gBAFJ,GAEW,IAAIO,IAAJ,CAAS,CAACE,KAAV,CAFX;AAAA;AAAA,mBAGMT,IAHN;;AAAA;;AAKAA,mBAAOU,SAASO,KAAT,CAAejB,IAAf,CAAP;;AALA,iBAOIW,GAPJ;AAAA;AAAA;AAAA;;AAAA;AAAA,kBAQSX,OAAOW,GARhB;AAAA;AAAA;AAAA;;AAAA;AAAA,mBASUX,IATV;;AAAA;AAUIA,mBAAOU,SAASO,KAAT,CAAejB,IAAf,CAAP;AAVJ;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAaWmB,aAbX,GAae,CAbf;;AAAA;AAAA,kBAakBA,IAAIP,UAbtB;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAcUZ,IAdV;;AAAA;AAeIA,mBAAOU,SAASO,KAAT,CAAejB,IAAf,CAAP;;AAfJ;AAakCmB,eAblC;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,yDAmBO;AAAA,WAAM,oBAAWD,MAAX,CAAN;AAAA,GAnBP,sDAoBQ;AAAA,kBAAUA,OAAOE,OAAP,GAAiBC,MAAjB,GAA0B,CAApC,UAAyCZ,MAAMa,WAAN,EAAzC,SAAgEZ,QAAhE;AAAA,GApBR,WAAJ;;AAuBA,SAAO,sBAAcQ,MAAd,CAAP;AACD;;kBAEcV,Y","file":"period.js","sourcesContent":["'use strict';\n\nimport createDuration from 'date-duration';\n\nconst filterDate = date => {\n  if (typeof date.toDate === 'function') {\n    date = date.toDate();\n  }\n\n  if (Object.prototype.toString.call(date) !== '[object Date]') {\n    throw new Error('Invalid date');\n  }\n\n  return new Date(+date);\n};\n\nfunction createPeriod ({start, duration, end, recurrence, iso}) {\n  if (iso) {\n    if (typeof iso !== 'string' || iso[0] !== 'R') {\n      throw new Error('Invalid period (invalid ISO format)');\n    }\n\n    [recurrence, start, duration] = iso.split(/\\//);\n\n    start = new Date(start);\n    recurrence = parseInt(recurrence.substr(1), 10);\n  }\n\n  start = filterDate(start);\n\n  if (typeof duration === 'object' && typeof duration.toString === 'function') {\n    duration = duration.toString();\n  }\n\n  duration = createDuration(duration);\n\n  if (end) {\n    end = filterDate(end);\n  } else if (recurrence) {\n    if (typeof recurrence !== 'number') {\n      throw new Error('Invalid period (invalid number of recurrences)');\n    }\n  } else {\n    throw new Error('Invalid period (missing end or number of recurrences)');\n  }\n\n  if (end && start >= end) {\n    throw new Error('Invalid period (end needs to be after start)');\n  }\n\n  if (+start === +duration.addTo(start)) {\n    throw new Error(`Invalid period (no duration)`);\n  }\n\n  let period = {\n    * [Symbol.iterator] () {\n      let date = new Date(+start);\n      yield date;\n\n      date = duration.addTo(date);\n\n      if (end) {\n        while (date < end) {\n          yield date;\n          date = duration.addTo(date);\n        }\n      } else {\n        for (let i = 0; i < recurrence; i++) {\n          yield date;\n          date = duration.addTo(date);\n        }\n      }\n    },\n    toArray: () => Array.from(period),\n    toString: () => `R${period.toArray().length - 1}/${start.toISOString()}/${duration}`\n  };\n\n  return Object.freeze(period);\n}\n\nexport default createPeriod;\n"]}